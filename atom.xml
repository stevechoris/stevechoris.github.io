<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Choris Steve&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yingshu.ink/"/>
  <updated>2017-04-05T12:27:16.000Z</updated>
  <id>http://www.yingshu.ink/</id>
  
  <author>
    <name>影书</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何从零构建一个卷积神经网络分类器 - TensorFlow学习整理</title>
    <link href="http://www.yingshu.ink/2017/02/21/%E5%A6%82%E4%BD%95%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%99%A8-TensorFlow%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://www.yingshu.ink/2017/02/21/如何从零构建一个卷积神经网络分类器-TensorFlow学习整理/</id>
    <published>2017-02-21T06:40:42.000Z</published>
    <updated>2017-04-05T12:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><blockquote>
<p>参考Deep Learning Tutorial</p>
</blockquote>
<h2 id="tensorflow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><blockquote>
<ul>
<li>TensorFlow是一个基于数据流图的深度学习框架</li>
<li>图中的节点表示数学运算，而图边表示在它们之间传递的张量（多维数组）</li>
<li>TensorFlow的优点是架构非常灵活，允许你通过<strong>单一的API</strong>将计算部署到PC机，服务器或移动设备的一个或多个CPU或GPU</li>
<li>目前的版本是1.0，基于8GPU对Inception V3实现了7.3倍加速，以及基于64GPU对分布式Inception V3训练实现58倍加速。主要引入了以下新的特点：<ul>
<li>提供Java和Go的实验API</li>
<li>引入了高级API模块：<code>tf.contrib.learn</code>，还包含一个全新的<code>tf.keras</code>模块，能够与高级神经网络库Keras完全兼容</li>
<li>发布了面向CPU和GPU的TensorFlow图形的特定领域编译器XLA的实验版本</li>
<li>生成TensorFlow Debugger(tfdbg)，一个用于调试实时TensorFlow程序的命令行界面和API</li>
</ul>
</li>
</ul>
<p>接下来我将结合如何从零开始构建一个卷积神经网络图像分类器来介绍并总结TensorFlow的使用经验</p>
</blockquote>
<h3 id="图像数据的创建"><a href="#图像数据的创建" class="headerlink" title="图像数据的创建"></a>图像数据的创建</h3><p><img src="https://lh3.googleusercontent.com/-bfpA60gUBjo/WKml0jD5eqI/AAAAAAAAAUQ/U_4EtRPZ88I/I/%25255BUNSET%25255D.png" alt="数据获取与组织"></p>
<h3 id="读取图片并保存为tfrecords文件"><a href="#读取图片并保存为tfrecords文件" class="headerlink" title="读取图片并保存为tfrecords文件"></a>读取图片并保存为tfrecords文件</h3><blockquote>
<p>.tfrecords文件为TensorFlow特有的序列化，保存数据的文件。便于后续的大数据的读取。</p>
</blockquote>
<p><img src="https://lh3.googleusercontent.com/-vNuMu38aATc/WKmuEIr8_KI/AAAAAAAAAUs/o12aj7W4oUk/I/14875150953274.jpg" alt=""></p>
<h3 id="训练时数据的读取"><a href="#训练时数据的读取" class="headerlink" title="训练时数据的读取"></a>训练时数据的读取</h3><p><img src="https://lh3.googleusercontent.com/-Q54gpCCUu-g/WKmuETFjm6I/AAAAAAAAAUw/cfJ_an92XNw/I/14875151258687.jpg" alt=""></p>
<h3 id="模型的定义"><a href="#模型的定义" class="headerlink" title="模型的定义"></a>模型的定义</h3><blockquote>
<p>到上一步为止，我们已经可以获得用于训练的一个batch的examples和labels，其本质为numpy数组。如果你直接有numpy数组数据，也可以直接用于训练或预测。<br>Tensorflow运行需要两步：1. 定义图的结构 2. 将操作放到一个会话中(Session)中运行。<br>因此，在TensorFlow可以运行之前，我们必须先定义Graph，它是整个模型的结构。 </p>
</blockquote>
<p>TensorFlow模型主要有三个部分，和机器学习算法的三个主要部分对应。</p>
<ul>
<li>Inference: 定义神经网络的输入，输出，隐含层单元以及权重，对于一个batch的输入，可以通过前馈计算，输出一个batch的logits(可以理解为每一类的输出大小)。</li>
<li>Loss: 通过logits和labels计算出当前输出结果的预测值与实际值之间差距的大小。通常使用的是softmax_cross_entropy</li>
<li>Training: 通常使用的AdamOptimizer（自适应的随机梯度下降方法）。涉及到权重衰减，自适应学习率和动量等，使得模型不断趋向于最优解。不会限于局部最优且不会过冲。</li>
</ul>
<h4 id="inference中用到的主要函数"><a href="#Inference中用到的主要函数" class="headerlink" title="Inference中用到的主要函数"></a>Inference中用到的主要函数</h4><h5 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h5><ul>
<li><code>tf.get_variable</code> # 定义卷积核与偏置的初始权值</li>
<li><code>tf.add_to_collection</code> # 添加变量到字典中</li>
<li><code>tf.nn.conv2d</code> # 卷积</li>
<li><code>tf.nn.bias_add</code> # 偏置</li>
</ul>
<h5 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h5><ul>
<li><code>tf.nn.max_pool</code></li>
</ul>
<h5 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h5><ul>
<li><code>tf.get_variable</code> # 定义全连接和偏置的初始权值</li>
<li><code>tf.reshape</code> # 可能需要将最后池化层结果拉长成一个向量</li>
<li><code>tf.nn.relu_layer</code> # 添加ReLU非线性模块</li>
</ul>
<h5 id="dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h5><ul>
<li><code>tf.nn.dropout</code> # 在最后全连接层后加入dropout</li>
</ul>
<h5 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h5><ul>
<li><code>tf.get_variable</code> # 定义全连接和偏置的初识权值</li>
<li><code>tf.add(tf.matmul())</code> # 最后全连接方式输出logits</li>
</ul>
<blockquote>
<p>注意当模型复杂化的时候可以使用<code>tf.variable_scope</code>和<code>tf.name_scope</code>函数来共享参数。<br>其中<code>tf.variable_scope</code>主要影响变量的命名，但默认会调用<code>tf.name_scope</code>，而<code>tf.name_scope</code>只会影响ops的命名。</p>
</blockquote>
<h4 id="losslogits-labels中用到的主要函数"><a href="#Loss-logits-labels-中用到的主要函数" class="headerlink" title="Loss(logits, labels)中用到的主要函数:"></a>Loss(logits, labels)中用到的主要函数:</h4><ul>
<li><code>tf.reshape</code> # 将labels reshape为[batch_size, 1]大小</li>
<li><code>tf.concat</code> # 与同样大小的tf.range(0, batch_size)连接</li>
<li><code>tf.sparse_to_dense</code> # 稀疏矩阵转为稠密矩阵</li>
<li><code>tf.nn.softmax_cross_entropy_with_logits</code> # 计算交叉熵</li>
<li><code>tf.reduce_mean</code> # 计算平均值</li>
</ul>
<h4 id="trainingloss-global_step中用到的主要函数"><a href="#Training-loss-global-step-中用到的主要函数" class="headerlink" title="Training(loss, global_step)中用到的主要函数"></a>Training(loss, global_step)中用到的主要函数</h4><ul>
<li><code>tf.train.exponential_decay</code> # 权值衰减设置函数</li>
<li><code>optimizer=tf.train.AdamOptimizer</code> # 自适应梯度优化器</li>
<li><code>train_op=optimizer.minimize(loss, global_step=global_step)</code></li>
</ul>
<h4 id="evaluationlogits-labels-预测评估中用到的主要函数"><a href="#Evaluation-logits-labels-预测评估中用到的主要函数" class="headerlink" title="Evaluation(logits, labels) 预测评估中用到的主要函数"></a>Evaluation(logits, labels) 预测评估中用到的主要函数</h4><ul>
<li><code>tf.nn.in_top_k</code> # 计算每个实例的labels是否在logits预测的前k个类别中</li>
<li><code>tf.reduce_sum</code> # 计算预测正确的数量</li>
</ul>
<h3 id="模型运行"><a href="#模型运行" class="headerlink" title="模型运行"></a>模型运行</h3><h4 id="tensorflow的几个重要元素"><a href="#TensorFlow的几个重要元素" class="headerlink" title="TensorFlow的几个重要元素"></a>TensorFlow的几个重要元素</h4><h5 id="变量和操作"><a href="#变量和操作" class="headerlink" title="变量和操作"></a>变量和操作</h5><ul>
<li>Variable</li>
<li>Constant</li>
<li>Placeholder</li>
<li>其他各种OPs</li>
<li>Session</li>
</ul>
<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><ul>
<li><code>tf.global_variables_initializer()</code> # 用于初始化所有变量</li>
<li><code>input_pipeline()</code> # 从tfrecords读取数据</li>
<li><code>placeholder_inputs()</code> # 定义输入</li>
<li><code>inference()</code></li>
<li><code>loss()</code></li>
<li><code>training()</code></li>
<li><code>evaluation()</code></li>
<li><code>coord = tf.train.Coordinator()</code> # 用于驱动tfrecords数据的读取</li>
<li><code>threads = tf.train.start_queue_runners(sess=sess, coord=coord)</code></li>
<li><code>Session.run()</code></li>
</ul>
<h4 id="tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h4><blockquote>
<p>Tensorboard用于训练过程中相关信息的记录，便于可视化的分析和监视训练过程</p>
</blockquote>
<h5 id="相关函数"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h5><ul>
<li><code>tf.summary.scalar</code> # 定义各种标量信息，例如当前step的Accuracy, Loss等</li>
<li><code>tf.summary.image</code> # 保存当前batch的图片</li>
<li><code>tf.summary.merge_all()</code> # 将所有summary汇总为一个操作</li>
<li><code>summary_writer = tf.summary.FileWriter(log_dir,graph_def=sess.graph_def)</code> # 定义一个写summary的句柄</li>
<li><code>summary_str = sess.run([summary_op], feed_dict=summary_feed)</code> # 生成summary字符串</li>
<li><code>summary_writer.add_summary(summary_str[0], step)</code> # 将summary字符串用句柄写入文件</li>
</ul>
<h4 id="模型保存与加载"><a href="#模型保存与加载" class="headerlink" title="模型保存与加载"></a>模型保存与加载</h4><h5 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h5><ul>
<li><code>saver = tf.train.Saver(max_to_keep=30)</code> # 定义一个模型保存器</li>
<li><code>checkpoint_path = os.path.join(checkpoint_dir, &#39;model.ckpt&#39;)</code> # 设置保存的位置</li>
<li><code>saver.save(sess, checkpoint_path, global_step=step)</code> # 保存模型（需要Session, 位置以及当前训练的步数）</li>
</ul>
<h5 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h5><ul>
<li><code>ckpt = tf.train.get_checkpoint_state(checkpoint_dir=checkpoint_dir)</code> # （通过路径找到保存的模型）</li>
<li><code>saver.restore(sess, ckpt.model_checkpoint_path)</code> # 加载模型</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.yingshu.ink/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Machine Learning" scheme="http://www.yingshu.ink/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://www.yingshu.ink/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="http://www.yingshu.ink/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python3.5 Anaconda3 Caffe深度学习框架搭建</title>
    <link href="http://www.yingshu.ink/2017/01/12/Python3-5-Anaconda3-Caffe%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.yingshu.ink/2017/01/12/Python3-5-Anaconda3-Caffe深度学习框架搭建/</id>
    <published>2017-01-12T03:59:22.000Z</published>
    <updated>2017-03-31T14:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><blockquote>
<p>&emsp;&emsp;本文主要介绍在Anaconda3和Python3.5的环境下搭建Caffe深度学习开发环境，主要创建了Caffe的Python接口。<br>&emsp;&emsp;强调Python3.5和Anaconda3是因为，Caffe还没有全面支持Python3，并且默认不使用Anaconda。<br>&emsp;&emsp;Python3.5是目前Python3的最新版本，而且安装过程相对比较复杂。我在安装的过程中前后折腾了很久，但同时也从中学到了许多从源码编译安装程序的知识。本文主要参考了以下博客，在此表示感谢（下文博客1即代表引用了下列的第1篇博客）：</p>
<ol>
<li><a href="http://coldmooon.github.io/2016/05/15/use_caffe_with_python3.5/" target="_blank" rel="external">在 python3.5 下使用 Caffe Using Caffe with Python3.5</a></li>
<li><a href="https://github.com/saiprashanths/dl-setup#caffe" target="_blank" rel="external">Setting up a Deep Learning Machine from Scratch (Software)</a></li>
<li><a href="http://www.jianshu.com/p/663029044efd" target="_blank" rel="external">Ubuntu16.04+matlab2014a+anaconda2+OpenCV3.1+caffe安装</a></li>
<li><a href="https://yangcha.github.io/Caffe-Conda/" target="_blank" rel="external">Install Caffe With Anaconda</a></li>
</ol>
</blockquote>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="ubuntu1404系统"><a href="#ubuntu14-04系统" class="headerlink" title="ubuntu14.04系统"></a>ubuntu14.04系统</h3><p>可以输入<code>cat /etc/issue</code>查看ubuntu的版本</p>
<p><img src="https://lh3.googleusercontent.com/-Vncx38SBlJE/WHcbuYf-cWI/AAAAAAAAATQ/wmEHr89ss68/I/14841947936350.jpg" alt=""></p>
<h3 id="显卡驱动与cuda安装"><a href="#显卡驱动与CUDA安装" class="headerlink" title="显卡驱动与CUDA安装"></a>显卡驱动与CUDA安装</h3><p>主要参考博客1上的步骤，Nvidia显卡驱动安装可以参考<a href="https://github.com/saiprashanths/dl-setup#nvidia-drivers" target="_blank" rel="external">Nvidia Drivers安装步骤</a>，CUDA安装可以参考<a href="https://github.com/saiprashanths/dl-setup#cuda" target="_blank" rel="external">CUDA安装步骤</a>，cuDNN安装可以参考<a href="https://github.com/saiprashanths/dl-setup#cudnn" target="_blank" rel="external">cuDNN安装步骤</a></p>
<h3 id="blas安装与配置"><a href="#BLAS安装与配置" class="headerlink" title="BLAS安装与配置"></a>BLAS安装与配置</h3><p>BLAS（基础线性代数集合）是一个应用程序接口的标准。Caffe官网上推荐了三种实现：ATLAS, MKL, or OpenBLAS。其中atlas可以直接通过命令行安装（本文采用的就是这个），如果要使用intel的MKL库，可以参考博客2的中BLAS安装与配置步骤。</p>
<h3 id="安装相关依赖包"><a href="#安装相关依赖包" class="headerlink" title="安装相关依赖包"></a>安装相关依赖包</h3><p>Caffe的编译依赖于很多C和C++的动态链接库，因此需要先用apt-get工具安装这些动态链接库。参考博客4主要步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update&#10;&#10;sudo apt-get upgrade&#10;&#10;sudo apt-get install -y build-essential cmake git pkg-config&#10;&#10;sudo apt-get install -y libprotobuf-dev libleveldb-dev libsnappy-dev protobuf-compiler&#10;&#10;sudo apt-get install -y libatlas-base-dev &#10;&#10;sudo apt-get install -y --no-install-recommends libboost-all-dev&#10;&#10;sudo apt-get install -y libgflags-dev libgoogle-glog-dev liblmdb-dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据博客1这里有两个包的版本要注意：<br>protobuf版本要3.0或以上版本<br>libboost版本要1.55或以上版本<br>下面介绍这两个包的具体配置</p>
</blockquote>
<h3 id="protobuf安装"><a href="#protobuf安装" class="headerlink" title="protobuf安装"></a>protobuf安装</h3><p>博客博客1提到使用apt-get安装的是2.0版本，不可以。因此需要到protobuf的<a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">release页面</a>下载两个安装包：</p>
<ul>
<li>protobuf-cpp-3.0.0-beta-2.zip 或以上版本；</li>
<li>protobuf-python-3.0.0-beta-2.zip 或以上版本。<br>注意<strong>cpp和python的版本应该保持一致</strong>。</li>
</ul>
<p>这里由于我在实际安装Caffe环境的时候发现protoc已经安装了，应该是之前用apt-get的时候安装的版本是可以的，并且使用<code>protoc --version</code>发现版本为3.0.0:<br><img src="https://lh3.googleusercontent.com/-OhWgjF1km4g/WHcbu7kdDiI/AAAAAAAAATU/PmQooA_z6fA/I/14841982449906.jpg" alt=""><br>所以应该是cpp这个包已经安装好了，我就只按照[^1]的步骤到<a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">release页面</a>下载并安装了对于的3.0.0版本的python包，安装步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#35299;&#21387;&#23433;&#35013;&#21253;&#65292;&#36827;&#20837;&#35299;&#21387;&#30340;&#30446;&#24405;&#10;$ cd python&#10;$ python setup.py build&#10;$ python setup.py test&#10;$ python setup.py install</span><br></pre></td></tr></table></figure>
<p>这样protobuf python runtime就编译和安装好了。注意protobuf python runtime是作为pip的包安装的。但是你可以从conda里面看到他：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda list | grep protobuf</span><br></pre></td></tr></table></figure>
<p><img src="https://lh3.googleusercontent.com/-I1_TDKgfPFw/WHcbvBGCXLI/AAAAAAAAATY/wgxyPm_C7Mc/I/14841986461841.jpg" alt=""></p>
<p>我这里貌似安装了两个版本的，不过有3.0.0版本的就可以了。</p>
<h3 id="libboost安装"><a href="#libboost安装" class="headerlink" title="libboost安装"></a>libboost安装</h3><p>按照博客1的解释，libboost安装完之后会产生两个版本的libboost_python:</p>
<ul>
<li>libboost_python-py33.so.XXX</li>
<li>libboost_python-py34.so.XXX</li>
</ul>
<p>而这里必须选择py34的动态链接库，否则在实际运行Caffe的时候可能会在得不到任何错误提示的情况下python kernel直接崩溃。</p>
<p>具体安装步骤可以参考博客1的步骤，这里有一个关键步骤必须要执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/lib/x86_64-linux-gnu/libboost_python-py34.so.1.55.0 /usr/local/lib/libboost_python3.so</span><br></pre></td></tr></table></figure>
<p>就是在/usr/local/lib目录下建立一个libboost_python3.so的软链接，而且到这里，需要配置一下.bashrc或者.zshrc的环境变量：<br><img src="https://lh3.googleusercontent.com/-l0dP6gA8yd8/WHcbvVmbmcI/AAAAAAAAATc/bKgrmZBVMTc/I/14841990222795.jpg" alt=""></p>
<p>这里主要是在LD_LIBRARY_PATH环境变量中添加了Anaconda，Caffe的链接库路径以及/usr/local/lib目录，这样在编译的时候才能找到比如上面libboost_python3.so这样的动态链接库文件。</p>
<blockquote>
<p>关于LD_LIBRARY_PATH环境变量以及ld.so.conf文件和ldconfig命令的使用，可以参考<a href="http://yiranwuqing.iteye.com/blog/974246" target="_blank" rel="external">Linux 共享库 LD_LIBRARY_PATH 与ld.so.conf的使用ldconfig</a></p>
</blockquote>
<h2 id="anaconda3以及caffe的编译和安装"><a href="#Anaconda3以及Caffe的编译和安装" class="headerlink" title="Anaconda3以及Caffe的编译和安装"></a>Anaconda3以及Caffe的编译和安装</h2><h3 id="anaconda3安装"><a href="#Anaconda3安装" class="headerlink" title="Anaconda3安装"></a>Anaconda3安装</h3><p>Anaconda3的安装比较简单，在<a href="https://www.continuum.io/" target="_blank" rel="external">Anaconda官网</a>下载对于的Linux安装包（.sh文件）即可，安装命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-4.0.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>安装完Anaconda3之后可以参考博客4的建议，安装一下OpenCV包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c menpo opencv3</span><br></pre></td></tr></table></figure>
<h3 id="caffe的编译和安装"><a href="#Caffe的编译和安装" class="headerlink" title="Caffe的编译和安装"></a>Caffe的编译和安装</h3><p>到这里就可以正式进行Caffe的编译和安装了，首先下载并解压，这一步大家都会，到github官网下载即可，解压后进入Caffe目录。</p>
<p>这里的主要步骤是Makefile.config文件的配置,首先运行<code>cp Makefile.config.example Makefile.config</code>创建一个Makefile.config，然后对其中内容进行更改，运行<code>vim Makefile.config</code>打开文件，进行如下修改：</p>
<p><img src="https://lh3.googleusercontent.com/-2RWbsaYISiU/WHcbv45RSuI/AAAAAAAAATg/MlIsKmbBCkc/I/14841999824009.jpg" alt=""><br><img src="https://lh3.googleusercontent.com/-FYMfZOZcp7w/WHcbxdcn-UI/AAAAAAAAATk/oaLzYNMGyAo/I/14842000459165.jpg" alt=""><br><img src="https://lh3.googleusercontent.com/-h8acahv-hqU/WHcb0jz0EpI/AAAAAAAAATo/zOInspf24BE/I/14842000687384.jpg" alt=""><br>其中有几个地方需要注意：</p>
<ul>
<li>USE_CUDNN:=1 # 取消注释后需要保证，在ld.so.conf文件中（记住ldconfig）或LD_LIBRARY_PATH环境变量中能找到CUDNN的动态链接库</li>
<li>OPENCV_VERSION:=3 # 如果安装了OpenCV3可以启用这一项</li>
<li>BLAS:=atlas # 如果使用别的MKL或者BLAS需要在下面几行配置目录</li>
<li>ANACONDA_HOME和PYTHON_INCLUDE # 按照我上面的修改即可</li>
<li>PYTHON_LIBRARIES # 同意确保boost_python3这个动态链接库在ld.so.conf文件中（记住ldconfig）或LD_LIBRARY_PATH中能找到。可以用<code>locate boost_python</code>命令看看动态链接库文件藏在哪里，然后把相应的目录添加到LD_LIBRARY_PATH环境变量中。</li>
<li>PYTHON_LIB # 需要启用</li>
<li>WITH_PYTHON_LAYER # 如果要使用Caffe的Python接口就需要启用</li>
</ul>
<p>以上都配置完了之后，就可以编译Caffe以及Caffe的Python接口啦，参考[^2]可以使用多线程提高编译的速度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all -j $(($(nproc) + 1))&#10;make test -j $(($(nproc) + 1))&#10;make runtest -j $(($(nproc) + 1))&#10;make pycaffe -j $(($(nproc) + 1))</span><br></pre></td></tr></table></figure>
<p>如果一切都顺利的话，到这里Caffe以及Caffe的Python接口已经编译完成并可以使用了。最后把Caffe的Python库的路径添加到PYTHONPATH环境变量中，这样在python或者ipython程序中才能import进来：</p>
<p><img src="https://lh3.googleusercontent.com/-mLTFnG2YcJM/WHcb0zYhohI/AAAAAAAAATs/d8bvG7mUVu0/I/14842006899958.jpg" alt=""></p>
<p>PS：修改.bashrc或.zshrc之后记得<code>source ~/.bashrc</code>或者<code>source  ~/.zshrc</code>一下才生效哦。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>打开python或ipython已经可以正常使用caffe了。</p>
<p><img src="https://lh3.googleusercontent.com/-HceH23w4JFs/WHcb1efNFtI/AAAAAAAAATw/IH_MJ3fu-5c/I/14842008115134.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="开发环境和操作系统" scheme="http://www.yingshu.ink/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Anaconda" scheme="http://www.yingshu.ink/tags/Anaconda/"/>
    
      <category term="Caffe" scheme="http://www.yingshu.ink/tags/Caffe/"/>
    
      <category term="Python" scheme="http://www.yingshu.ink/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令整理</title>
    <link href="http://www.yingshu.ink/2016/12/28/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://www.yingshu.ink/2016/12/28/Linux常用命令整理/</id>
    <published>2016-12-28T07:52:12.000Z</published>
    <updated>2017-03-31T14:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h2><h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><h4 id="命令格式df-h"><a href="#命令格式：df-h" class="headerlink" title="命令格式：df -h"></a>命令格式：<code>df -h</code></h4><blockquote>
<p>以磁盘分区为单位查看文件系统</p>
</blockquote>
<p><img src="../../../../images/14829116578841.jpg" alt=""></p>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h3 id="查看占用特定端口的进程"><a href="#查看占用特定端口的进程" class="headerlink" title="查看占用特定端口的进程"></a>查看占用特定端口的进程</h3><blockquote>
<p>命令格式：<code>lsof -i:6006</code></p>
<p>其中6006为想要查看的端口</p>
</blockquote>
<p><img src="../../../../images/14829118493300.jpg" alt=""></p>
<h3 id="根据进程号kill特定进程"><a href="#根据进程号KILL特定进程" class="headerlink" title="根据进程号KILL特定进程"></a>根据进程号KILL特定进程</h3><blockquote>
<p>命令格式：<code>kill -KILL 738</code></p>
<p>其中738为想要kill的进程的进程号</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="Linux命令" scheme="http://www.yingshu.ink/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://www.yingshu.ink/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>[经典面试题] 最长回文子串</title>
    <link href="http://www.yingshu.ink/2016/12/21/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://www.yingshu.ink/2016/12/21/经典面试题-最长回文子串/</id>
    <published>2016-12-21T08:21:52.000Z</published>
    <updated>2017-03-31T09:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要参考<a href="http://mp.weixin.qq.com/s?src=3&amp;timestamp=1482308889&amp;ver=1&amp;signature=WTl9NE2n3M403BrLr2Xeh15hVeUNK1IGyrVBn7CDuy2Be1R46UBFS8xEZrf4-Z1GiWnRM6y4jCLhjXPaNUDUgWEkKV0jKFeG1xsC2co-k0RLqpqlfycUK4UV*pkIOQNSiDo4xEkL1FrlQnhslAFGVA==" target="_blank" rel="external">微信公众号(待字闺中)推文”【经典面试题】最长回文”
</a>整理而成，在此特别感谢。</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="external">LeetCode 5. Longest Palindromic Substring</a></p>
<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example:</p>
<blockquote>
<p>Input: “babad”</p>
<p>Output: “bab”</p>
</blockquote>
<p>Note: “aba” is also a valid answer.<br>Example:</p>
<blockquote>
<p>Input: “cbbd”</p>
<p>Output: “bb”</p>
</blockquote>
<p>&emsp;<a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h3><p>在外层使用2重循环找出所有子串，内层循环判断当前子串是否为回文子串。</p>
<blockquote>
<p>时间复杂度为$O(n^3)$，空间复杂度为$O(1)$</p>
</blockquote>
<h3 id="2-动态规划方法"><a href="#2-动态规划方法" class="headerlink" title="2. 动态规划方法"></a>2. 动态规划方法</h3><p>开辟一个二维数组p[i][j]用来表示str[i…j]是否为回文子串，p[i][j]的状态转移方程为：</p>
<ol>
<li>i==j时，<code>p[i][j]=true</code></li>
<li>i+1==j时，<code>p[i][j]=(str[i]==str[j])</code></li>
<li>其他情况,<code>p[i][j]=(str[i]==str[j] &amp;&amp; p[i+1]==p[j-1])</code></li>
</ol>
<blockquote>
<p>时间复杂度为$O(n^2)$，空间复杂度为$O(n^2)$, 时间上比暴力法有较大优化。</p>
</blockquote>
<h3 id="3-确定中心后像两边扩展"><a href="#3-确定中心后像两边扩展" class="headerlink" title="3. 确定中心后像两边扩展"></a>3. 确定中心后像两边扩展</h3><p>可以先确定一个字符为中心，然后向两边扩展，需要注意的是<strong>要同时考虑奇数和偶数的情况</strong>。</p>
<blockquote>
<p>时间复杂度为$O(n^2)$，空间复杂度为$O(1)$</p>
</blockquote>
<h3 id="4-后缀数组"><a href="#4-后缀数组" class="headerlink" title="4. 后缀数组"></a>4. 后缀数组</h3><p>可以利用后缀数组，将最长回文子串问题转换为求后缀数组中最长公共前缀的问题。具体做法是将字符串反转，拼接到原字符之后，中间注意用特殊字符隔开。然后求新字符串的后缀数组的任意两个字符串的最大公共前缀。</p>
<p>例如原字符串s0=”abcbd”，那转换后编程s1=”abcbd#dbcba”，则后缀数组为：<br>“a”<br>“ba”<br>“cba”<br>“bcba”<br>“dbcba”<br>“#dbcba”<br>“d#dbcba”<br>“bd#dbcba”<br>“cbd#dbcba”<br>“bcbd#dbcba”<br>“abcbd#dbcba”<br>可以看出，字符串”bcba”和“bcbd#dbcba”的最大公共前缀=3，长度最长。</p>
<blockquote>
<p>具体实现算法好坏可能导致复杂度差异很大。</p>
</blockquote>
<h3 id="5-manacher算法"><a href="#5-Manacher算法" class="headerlink" title="5. Manacher算法"></a>5. Manacher算法</h3><p>Manacher算法是一种接近线性时间的算法，在上面方法3中需要考虑回文长度为奇数和偶数的情况，这里引入一个技巧，通过在字符之间插入特殊字符（例如#字符）可以统一处理。<br>例如字符串“abba”，插入#字符后转换为“#a#b#b#a#”，然后创建一个数组p，计算以当前第i个字符为中心的回文串的半径。<br><img src="../../../../images/14823759882277.jpg" alt=""><br>可以发现任意一个回文串的长度都是奇数，而且该回文串包含的原字符串中的字符个数=p[i]-1，且这些原字符一定构成回文串。</p>
<p>具体的算法详解可以参考<a href="http://mp.weixin.qq.com/s?src=3&amp;timestamp=1482308889&amp;ver=1&amp;signature=WTl9NE2n3M403BrLr2Xeh15hVeUNK1IGyrVBn7CDuy2Be1R46UBFS8xEZrf4-Z1GiWnRM6y4jCLhjXPaNUDUgWEkKV0jKFeG1xsC2co-k0RLqpqlfycUK4UV*pkIOQNSiDo4xEkL1FrlQnhslAFGVA==" target="_blank" rel="external">微信公众号(待字闺中)推文”【经典面试题】最长回文”
</a>和<a href="http://blog.csdn.net/xingyeyongheng/article/details/9310555" target="_blank" rel="external">hdu3068之manacher算法+详解</a>这两篇博客内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要参考&lt;a href=&quot;http://mp.weixin.qq.com/s?src=3&amp;amp;timestamp=1482308889&amp;amp;ver=1&amp;amp;signature=WTl9NE2n3M403BrLr2Xeh15hVeUNK1IGyrVBn7CDuy2Be1R46UBFS8xEZrf4-Z1GiWnRM6y4jCLhjXPaNUDUgWEkKV0jKFeG1xsC2co-k0RLqpqlfycUK4UV*pkIOQNSiDo4xEkL1FrlQnhslAFGVA==&quot;&gt;微信公众号(待字闺中)推文”【经典面试题】最长回文”
&lt;/a&gt;整理而成，在此特别感谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;LeetCode 5. Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: “babad”&lt;/p&gt;
&lt;p&gt;Output: “bab”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Note: “aba” is also a valid answer.&lt;br&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: “cbbd”&lt;/p&gt;
&lt;p&gt;Output: “bb”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.yingshu.ink/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法与数据结构" scheme="http://www.yingshu.ink/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="面试" scheme="http://www.yingshu.ink/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] Template</title>
    <link href="http://www.yingshu.ink/2016/12/17/LeetCode-Template/"/>
    <id>http://www.yingshu.ink/2016/12/17/LeetCode-Template/</id>
    <published>2016-12-17T03:10:08.000Z</published>
    <updated>2017-03-31T09:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>title: ‘[LeetCode] 174. Dungeon Game’<br>date: 2016-09-11 18:00:53<br>categories: LeetCode</p>
<h2 id="tags-leetcode-dynamic-programming-string-stack"><a href="#tags-LeetCode-Dynamic-Programming-String-Stack" class="headerlink" title="tags: [LeetCode, Dynamic Programming, String, Stack]"></a>tags: [LeetCode, Dynamic Programming, String, Stack]</h2><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="external">174. Dungeon Game</a><br>The demons had captured the princess (<em>P</em>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<em>K</em>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p><em>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</em></p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<p><img src="https://lh3.googleusercontent.com/-OK3mhMH5MAI/V9VGGlpt63I/AAAAAAAAAO4/kfxbG2D6x0E/I/14735883347096.jpg" alt=""><br><!-- more --></p>
<h2 id="notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h2><p>The knight’s health has no upper bound.<br>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>骑士需要从左上角开始进入房间，每次向右或向下移动一步进入下一个房间，直到到达右下角的房间救出公主。每个房间可能由精灵把守，会造成骑士失血，用负数表示；可能为空，用0表示；也可能有魔法球，可以给骑士补血。从左上角第一个房间开始，直到进入右下角关押公主的房间，血量都不能&lt;=0。</p>
<h1 id="解题思路"><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这是一道二维的动态规划问题，用DP[i][j]表示状态，表示接下来骑士进入(i,j)房间后能救出公主最少需要具备多少血。状态转移方程为:</p>
<p>$ dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1) $ (1)</p>
<p>选择向右或者向下中代价最小的方向，然后根据当前要进入的房间(i,j)相应调整需要的血量。</p>
<p>若$dungeon[i][j] &lt;= 0$,则$dp[i][j] =  min(dp[i+1][j], dp[i][j+1])-dungeon[i][j]$ (2)</p>
<p>若$dungeon[i][j] &gt; 0$,则$dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1) $ (3) </p>
<p>(2)、（3）式可以统一为（1）式子。</p>
<h1 id="c代码"><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    int calculateMinimumHP(vector&#60;vector&#60;int&#62;&#62;&#38; dungeon) &#123;&#10;        int rows = dungeon.size();&#10;        int cols = dungeon[0].size();&#10;        vector&#60;vector&#60;int&#62;&#62; dp(rows, vector&#60;int&#62;(cols, 0));&#10;        dp[rows-1][cols-1] = max(1-dungeon[rows-1][cols-1], 1);&#10;        &#10;        for (int i=rows-2; i&#62;=0; i--) &#123;&#10;            dp[i][cols-1] =  max(dp[i+1][cols-1]-dungeon[i][cols-1], 1);&#10;        &#125;&#10;        for (int j=cols-2; j&#62;=0; j--) &#123;&#10;            dp[rows-1][j] =  max(dp[rows-1][j+1]-dungeon[rows-1][j], 1);&#10;        &#125;&#10;        for (int i=rows-2; i&#62;=0; i--) &#123;&#10;            for (int j=cols-2; j&#62;=0; j--) &#123;&#10;                dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1);&#10;            &#125;&#10;        &#125;&#10;        return dp[0][0];&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="模板" scheme="http://www.yingshu.ink/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
      <category term="模板" scheme="http://www.yingshu.ink/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>用Anaconda安装配置Jupyter Notebook和TensorFlow开发环境</title>
    <link href="http://www.yingshu.ink/2016/09/15/%E7%94%A8Anaconda%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEJupyter-Notebook%E5%92%8CTensorFlow%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.yingshu.ink/2016/09/15/用Anaconda安装配置Jupyter-Notebook和TensorFlow开发环境/</id>
    <published>2016-09-15T11:02:18.000Z</published>
    <updated>2017-03-31T14:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h1><p>在<a href="https://www.continuum.io/downloads" target="_blank" rel="external">Anaconda官网</a>下载并按照指令安装。</p>
<blockquote>
<p>建议安装Python3版本，我在ubuntu14上测试发现安装Python2版本一直有<a href="http://stackoverflow.com/questions/37232446/ipython-console-cant-locate-backports-shutil-get-terminal-size-and-wont-load" target="_blank" rel="external">IPython console can’t locate “backports.shutil_get_terminal_size” and won’t load</a>的错误，按照stackoverflow上面的方法尝试也无法解决。之后看到有人评论说Python2目前已经过时了，于是重新安装了Python3版本的Anaconda后解决。</p>
</blockquote>
<h1 id="tensorflow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h1><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>在Anaconda中可以使用<a href="http://conda.pydata.org/docs/" target="_blank" rel="external">conda</a>或者<a href="https://pypi.python.org/pypi/pip" target="_blank" rel="external">pip</a>进行包管理，可以查看<a href="http://conda.pydata.org/docs/_downloads/conda-cheatsheet.pdf" target="_blank" rel="external">conda常用命令</a>和<a href="http://dcjtech.info/wp-content/uploads/2015/10/Pip-Cheatsheet.pdf" target="_blank" rel="external">pip常用命令</a>。conda可以看做是pip和virtualenv的集成，三者的常见命令对比可以查看<a href="[conda vs. pip vs. virtualenv](">conda vs. pip vs. virtualenv</a>)。</p>
<h2 id="安装包命令网速慢解决方法"><a href="#安装包命令网速慢解决方法" class="headerlink" title="安装包命令网速慢解决方法"></a>安装包命令网速慢解决方法</h2><h3 id="使用pip安装离线下载的whl格式安装包"><a href="#使用pip安装离线下载的whl格式安装包" class="headerlink" title="使用pip安装离线下载的whl格式安装包"></a>使用pip安装离线下载的whl格式安装包</h3><p>&emsp;&emsp;可以从<a href="https://pypi.python.org/pypi" target="_blank" rel="external">PyPI Python安装包中心</a>搜索并下载相应的按照包之后在本地离线安装。<br>&emsp;&emsp;例如，在下载名为<a href="https://pypi.python.org/pypi/kivy.deps.gstreamer/0.1.9" target="_blank" rel="external">kivy.deps.gstreamer</a>的包kivy.deps.gstreamer-0.1.9-cp27-cp27m-win_amd64.whl，则安装命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install kivy.deps.gstreamer-0.1.9-cp27-cp27m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<h3 id="使用shadowsocksprivoxyproxychains-ng搭建局域网翻墙代理"><a href="#使用shadowsocks-privoxy-proxychains-ng搭建局域网翻墙代理" class="headerlink" title="使用shadowsocks)+privoxy+proxychains-ng搭建局域网翻墙代理"></a>使用<strong><a href="[shadowsocks](">shadowsocks</a>)</strong>+<strong><a href="https://www.privoxy.org/" target="_blank" rel="external">privoxy</a></strong>+<strong><a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">proxychains-ng</a></strong>搭建局域网翻墙代理</h3><blockquote>
<p>&emsp;&emsp;这适用于服务器不适合直接搭建shadowsocks翻墙的情况，如果可以直接用shadowsocks翻墙，自然不需要这样做了。<br>&emsp;&emsp;我的情况是自己的Mac笔记本可以使用<a href="https://greenss.org/" target="_blank" rel="external">shadowsocks</a>[以下简称SS]或者<a href="https://ybb1024.com/" target="_blank" rel="external">鱼摆摆</a>进行翻墙，而ubuntu服务器无法翻墙。因此，我在Mac上用SS或者鱼摆摆翻墙，然后用privoxy与之相连，在本地建立一个局域网http翻墙代理，最后在ubuntu服务器上使用proxychains-ng代理到Mac上实现翻墙来安装包。</p>
</blockquote>
<p>具体的配置可以参看下面两篇博客：</p>
<blockquote>
<p>&emsp;&emsp;实际上我在配置的过程中，用privoxy代理到鱼摆摆的本地http代理端口可以正常使用，但是代理到socks5端口就不行，具体原因不太清楚。</p>
</blockquote>
<ol>
<li><a href="http://inorz.net/2015/05/24/init-privoxy-to-centos/" target="_blank" rel="external">privoxy配置</a></li>
<li><a href="http://www.nenew.net/ubuntu-linux-proxychains.html" target="_blank" rel="external">proxycahins-ng配置</a></li>
</ol>
<h2 id="安装tensorflow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h2><p>&emsp;&emsp;直接参考<a href="https://www.tensorflow.org/get_started/os_setup" target="_blank" rel="external">TensorFlow官网的安装教程即可</a>， 注意显卡驱动，Cuda Toolkit以及cuDNN需要正确的配置。具体可以参考官网或者<a href="https://github.com/saiprashanths/dl-setup" target="_blank" rel="external">github上的深度学习框架搭建</a>博客，其中包含了各种深度学习框架的搭建方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="开发环境和操作系统" scheme="http://www.yingshu.ink/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Anaconda" scheme="http://www.yingshu.ink/tags/Anaconda/"/>
    
      <category term="Conda" scheme="http://www.yingshu.ink/tags/Conda/"/>
    
      <category term="Python" scheme="http://www.yingshu.ink/tags/Python/"/>
    
      <category term="TensorFlow" scheme="http://www.yingshu.ink/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 32. Longest Valid Parentheses</title>
    <link href="http://www.yingshu.ink/2016/09/12/LeetCode-32-Longest-Valid-Parentheses/"/>
    <id>http://www.yingshu.ink/2016/09/12/LeetCode-32-Longest-Valid-Parentheses/</id>
    <published>2016-09-12T14:08:55.000Z</published>
    <updated>2017-03-31T09:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="external">32. Longest Valid Parentheses</a></p>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<p>Subscribe to see which companies asked this question</p>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给定一个仅包含’(‘和’)’的字符串，找出最长有效括号匹配子串的长度。 对于”(()”, 最长的有效括号匹配子串为”()”,长度为2。</p>
<p>另一个例子是”)()())”,最长的有效括号匹配子串为”()()”, 长度为4。</p>
<h1 id="解题思路"><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h2 id="解法1-栈stack"><a href="#解法1-栈（Stack）" class="headerlink" title="解法1 栈（Stack）"></a>解法1 栈（Stack）</h2><p>引用<a href="http://mp.weixin.qq.com/s?src=3&amp;timestamp=1473686658&amp;ver=1&amp;signature=FjA7yVpEGqFGtSgxwobBBt3rKzs4TlAd6VhHAhJB1*RqJ-BuT23ywidQwlW-YhzgzqWrTVPKbvBiaQGL-lpBLOASbqi7kDUMiCMHKeDUKMwp6kXG1YXWdybs*xbOuh9SN4iWdD4g7xMz5Vlk613TBj1V-gb8oylIm2HxjjS8ZFo=" target="_blank" rel="external">克林32. Longest Valid Parentheses</a>的思路。<br>括号匹配经常会用到栈，当碰到做括号’(‘时，将字符压入栈中，当碰到’)’字符时查看栈顶元素，若栈顶元素为’(‘，则将栈顶元素弹出，否则栈为空或者栈顶元素为’)’，匹配失败，将其压入栈中。因此，最终遍历完整个字符串后栈中剩下的元素就是无法匹配的字符，而它们间隔开的就是所有括号有效匹配的字串。因此，在入栈的时候需要加入当前字符的索引，最后一次出栈的时候可以计算中间的间隔字符数量，最大的即是结果。</p>
<h2 id="c代码"><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct PT &#123;&#10;    char ch;&#10;    int pos;&#10;    PT(char ch_, int pos_):ch(ch_),pos(pos_)&#123;&#125;&#10;&#125;;&#10;&#10;class Solution &#123;&#10;public:&#10;    int longestValidParentheses(string s) &#123;&#10;        if (s.empty()) return 0;&#10;        stack&#60;PT&#62; sk;&#10;        for (int i = 0; i &#60; s.length(); i++) &#123;&#10;            int character = s[i];&#10;            if (character == &#39;(&#39;) &#123;&#10;                sk.push(PT(&#39;(&#39;, i));&#10;            &#125; else &#123;&#10;                if (!sk.empty() &#38;&#38; sk.top().ch==&#39;(&#39;) &#123;&#10;                    sk.pop();&#10;                &#125; else &#123;&#10;                    sk.push(PT(&#39;)&#39;,i));&#10;                &#125;&#10;            &#125;&#10;        &#125;&#10;        int ans = 0;&#10;        int pre_pos = s.length();&#10;        while (!sk.empty()) &#123;&#10;            int now_pos = sk.top().pos;&#10;            sk.pop();&#10;            ans = max(ans, pre_pos-now_pos - 1);&#10;            pre_pos = now_pos;&#10;        &#125;&#10;        ans = max(ans, pre_pos);&#10;        return ans;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法2-动态规划dynamic-programming"><a href="#解法2-动态规划-Dynamic-Programming" class="headerlink" title="解法2 动态规划(Dynamic Programming)"></a>解法2 动态规划(Dynamic Programming)</h2><p>时间复杂度O(N),空间复杂度O(N)<br>参考<a href="https://segmentfault.com/a/1190000003481194" target="_blank" rel="external">https://segmentfault.com/a/1190000003481194</a>的思路<br>还可以用动态规划的方法，状态dp[i]表示从下标i开始直到字符串结尾最长括号对长度，s[i]是字符串下标为i的括号。如果s[i]是左括号，而且i+d[i+1]+1是右括号的话，那么d[i] == d[i+1]+1，如果不是则为0。如果s[i]是右括号，因为没有右括号开头的括号对，因此d[i]=0。此外还需要加上dp[i+dp[i+1]+1+1)。</p>
<h2 id="c代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;&#10;    public int longestValidParentheses(String s) &#123;&#10;        int[] dp = new int[s.length()];&#10;        int maxLen = 0;&#10;        for(int i = s.length()-2; i &#62;=0; i--)&#123;&#10;            if(s.charAt(i)==&#39;(&#39;)&#123;&#10;                int end = i + dp[i+1] + 1;&#10;                if(end &#60; s.length() &#38;&#38; s.charAt(end)==&#39;)&#39;)&#123;&#10;                    dp[i] = dp[i+1] + 2;&#10;                    if(end + 1 &#60; s.length())&#123;&#10;                        dp[i] += dp[end + 1];&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;            maxLen = Math.max(maxLen, dp[i]);&#10;        &#125;&#10;        return maxLen;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.yingshu.ink/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://www.yingshu.ink/tags/Stack/"/>
    
      <category term="String" scheme="http://www.yingshu.ink/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 312. Burst Balloons</title>
    <link href="http://www.yingshu.ink/2016/09/11/LeetCode-312-Burst-Balloons/"/>
    <id>http://www.yingshu.ink/2016/09/11/LeetCode-312-Burst-Balloons/</id>
    <published>2016-09-11T14:16:07.000Z</published>
    <updated>2017-03-31T09:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="external">312. Burst Balloons</a><br>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] <em> nums[i] </em> nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<h2 id="note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p>(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<h2 id="example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><p>Given [3, 1, 5, 8]</p>
<p>Return 167</p>
<p>nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []</p>
<p>coins =  3 <em> 1 </em> 5 +  3 <em> 5 </em> 8 +  1 <em> 3 </em> 8 + 1 <em> 8 </em> 1 = 167</p>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给定n个气球，下标为0到n-1。每个气球上都标有一个数字，用数组nums表示。你被要求扎破所有气球。扎破第i个气球可以获得nums[left] <em> nums[i] </em> nums[right]枚硬币。这里left和right是与i相邻的下标。扎破气球以后，left和right就变成相邻的了。</p>
<p>寻找最优策略下可以获得的硬币数。</p>
<h1 id="解题思路-动态规划dynamic-programming"><a href="#解题思路：-动态规划（Dynamic-Programming）" class="headerlink" title="解题思路： 动态规划（Dynamic Programming）"></a>解题思路： 动态规划（Dynamic Programming）</h1><p>时间复杂度O(N^3)<br>题目需要采用逆向思维，整个题目可以理解为将一个区间的的气球依次炸掉获得硬币，可以控制最后炸掉哪个气球。状态dp[l][r]表示需要爆炸的区间，以最后一个爆破的气球m为界限，可以把问题转换为左右两个区域的子问题。<br>状态转移方程：<br><img src="https://lh3.googleusercontent.com/-VpgrtD2IjWU/V9fzN8eYx-I/AAAAAAAAAQc/m4vTG8alOeA/I/14737694297670.jpg" alt=""><br>dp[l][r]表示扎破（l,r)范围内所有气球获得的最大硬币数。 l与r的跨度k从2开始逐渐增大。</p>
<h1 id="c代码"><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h1><p>java版代码引用<a href="http://bookshadow.com/weblog/2015/11/30/leetcode-burst-balloons/" target="_blank" rel="external">书影博客[LeetCode]Burst Balloons </a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    int maxCoins(vector&#60;int&#62;&#38; nums) &#123;&#10;        int sz = nums.size();&#10;        vector&#60;vector&#60;int&#62;&#62; cnt(sz, vector&#60;int&#62;(sz, 0));&#10;        return maxC(nums, 0, nums.size() - 1, 1, 1, cnt);&#10;    &#125;&#10;    int maxC(vector&#60;int&#62;&#38; nums, int from, int to, int left, int right, vector&#60;vector&#60;int&#62;&#62;&#38; cnt) &#123;&#10;        if (from &#62; to) return 0;&#10;        if (cnt[from][to]) return cnt[from][to];&#10;        if (from == to &#38;&#38; from &#62;= 0 &#38;&#38; from &#60; nums.size()) &#123;&#10;            cnt[from][to] = nums[from] * left * right;&#10;            return nums[from] * left * right;&#10;        &#125;&#10;        &#10;        int max_num = -1;&#10;        for (int i = from; i &#60; nums.size() &#38;&#38; i &#60;= to; i++) &#123;&#10;            max_num = max(max_num, maxC(nums, from, i-1, left, nums[i], cnt)&#10;                + maxC(nums, i+1, to, nums[i], right, cnt) + nums[i] * left * right);&#10;        &#125;&#10;        cnt[from][to] = max_num;&#10;        return max_num;&#10;    &#125;&#10;&#125;;&#10;&#10;public class Solution &#123;&#10;    public int maxCoins(int[] iNums) &#123;&#10;        int[] nums = new int[iNums.length + 2];&#10;        int n = 1;&#10;        for (int x : iNums) if (x &#62; 0) nums[n++] = x;&#10;        nums[0] = nums[n++] = 1;&#10;&#10;        int[][] dp = new int[n][n];&#10;        for (int k = 2; k &#60; n; ++k)&#10;            for (int l = 0; l &#60; n - k; ++l) &#123;&#10;                int r = l + k;&#10;                for (int m = l + 1; m &#60; r; ++m)&#10;                    dp[l][r] = Math.max(dp[l][r], &#10;                        nums[l] * nums[m] * nums[r] + dp[l][m] + dp[m][r]);&#10;            &#125;&#10;    &#10;        return dp[0][n - 1];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.yingshu.ink/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 354. Russian Doll Envelopes</title>
    <link href="http://www.yingshu.ink/2016/09/11/LeetCode-354-Russian-Doll-Envelopes/"/>
    <id>http://www.yingshu.ink/2016/09/11/LeetCode-354-Russian-Doll-Envelopes/</id>
    <published>2016-09-11T11:54:05.000Z</published>
    <updated>2017-03-31T09:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="external">354. Russian Doll Envelopes</a></p>
<p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<h2 id="example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><p>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>题意比较简单，给定一定量不同长宽的信封，小的信封可以放在大的信封内部，问最多能嵌套放几个。</p>
<h1 id="解题思路"><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>首先将信封(w,h)按照按照宽度排序，宽度小的在宽度大的后面，若相等，则长度小的在前，这样排在后面的信封不可能包含在前面的信封之中。</p>
<p>动态规划的思想也从中而来，状态DP[i]表示第i个信封所包含的信封的数量。从上面可知，若一个信封包含其他的信封(DP[i]&gt;1)则，它包含的一定是排在它之前的某个信封，即状态转移方程为</p>
<p>对每个信封i，初始化： $DP[i] = 1$ (1)<br>对于i&gt;=2，<img src="https://lh3.googleusercontent.com/-hMRCL5fA6zs/V9VTz0o8YhI/AAAAAAAAAPY/3Kquslplmm4/I/14735984062721.jpg" alt=""></p>
<h1 id="c代码"><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct cmp &#123;&#10;  bool operator()(pair&#60;int,int&#62;&#38; a, pair&#60;int,int&#62;&#38; b) &#123;&#10;      return b.first &#60; a.first || (b.first==a.first &#38;&#38; b.second &#60;a.second);&#10;  &#125;  &#10;&#125;;&#10;class Solution &#123;&#10;public:&#10;    int maxEnvelopes(vector&#60;pair&#60;int, int&#62;&#62;&#38; envelopes) &#123;&#10;        sort(envelopes.begin(), envelopes.end());&#10;        int n = envelopes.size();&#10;        if (n &#60;= 1) return n;&#10;        &#10;        int ans = INT_MIN;&#10;        vector&#60;int&#62; dp(n, 1);&#10;        vector&#60;int&#62; pre(n, -1);&#10;        for (int i=1; i&#60;n; i++) &#123;&#10;            for (int j=0; j&#60;i; j++) &#123;&#10;                if (canContain(envelopes[i], envelopes[j]) &#38;&#38; dp[j]+1&#62;dp[i]) &#123;&#10;                    dp[i] = dp[j]+1;&#10;                    pre[i] = j;&#10;                &#125;&#10;            &#125;&#10;        &#125;&#10;        &#10;        for (int i=0; i&#60;n; i++) &#123;&#10;            ans = max(ans, dp[i]);&#10;        &#125;&#10;        return ans;&#10;    &#125;&#10;    &#10;    bool canContain(pair&#60;int,int&#62;&#38; a, pair&#60;int,int&#62;&#38; b) &#123;&#10;        return a.first &#62; b.first &#38;&#38; a.second &#62; b.second;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.yingshu.ink/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 174. Dungeon Game</title>
    <link href="http://www.yingshu.ink/2016/09/11/LeetCode-174-Dungeon-Game/"/>
    <id>http://www.yingshu.ink/2016/09/11/LeetCode-174-Dungeon-Game/</id>
    <published>2016-09-11T10:00:53.000Z</published>
    <updated>2017-03-31T09:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="external">174. Dungeon Game</a><br>The demons had captured the princess (<em>P</em>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<em>K</em>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p><em>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</em></p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<p><img src="https://lh3.googleusercontent.com/-OK3mhMH5MAI/V9VGGlpt63I/AAAAAAAAAO4/kfxbG2D6x0E/I/14735883347096.jpg" alt=""></p>
<h2 id="notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h2><p>The knight’s health has no upper bound.<br>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>骑士需要从左上角开始进入房间，每次向右或向下移动一步进入下一个房间，直到到达右下角的房间救出公主。每个房间可能由精灵把守，会造成骑士失血，用负数表示；可能为空，用0表示；也可能有魔法球，可以给骑士补血。从左上角第一个房间开始，直到进入右下角关押公主的房间，血量都不能&lt;=0。</p>
<h1 id="解题思路"><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这是一道二维的动态规划问题，用DP[i][j]表示状态，表示接下来骑士进入(i,j)房间后能救出公主最少需要具备多少血。状态转移方程为:</p>
<p>$ dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1) $ (1)</p>
<p>选择向右或者向下中代价最小的方向，然后根据当前要进入的房间(i,j)相应调整需要的血量。</p>
<p>若$dungeon[i][j] &lt;= 0$,则$dp[i][j] =  min(dp[i+1][j], dp[i][j+1])-dungeon[i][j]$ (2)</p>
<p>若$dungeon[i][j] &gt; 0$,则$dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1) $ (3) </p>
<p>(2)、（3）式可以统一为（1）式子。</p>
<h1 id="c代码"><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    int calculateMinimumHP(vector&#60;vector&#60;int&#62;&#62;&#38; dungeon) &#123;&#10;        int rows = dungeon.size();&#10;        int cols = dungeon[0].size();&#10;        vector&#60;vector&#60;int&#62;&#62; dp(rows, vector&#60;int&#62;(cols, 0));&#10;        dp[rows-1][cols-1] = max(1-dungeon[rows-1][cols-1], 1);&#10;        &#10;        for (int i=rows-2; i&#62;=0; i--) &#123;&#10;            dp[i][cols-1] =  max(dp[i+1][cols-1]-dungeon[i][cols-1], 1);&#10;        &#125;&#10;        for (int j=cols-2; j&#62;=0; j--) &#123;&#10;            dp[rows-1][j] =  max(dp[rows-1][j+1]-dungeon[rows-1][j], 1);&#10;        &#125;&#10;        for (int i=rows-2; i&#62;=0; i--) &#123;&#10;            for (int j=cols-2; j&#62;=0; j--) &#123;&#10;                dp[i][j] =  max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1);&#10;            &#125;&#10;        &#125;&#10;        return dp[0][0];&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.yingshu.ink/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://www.yingshu.ink/tags/Stack/"/>
    
      <category term="String" scheme="http://www.yingshu.ink/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 解题报告</title>
    <link href="http://www.yingshu.ink/2016/09/10/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://www.yingshu.ink/2016/09/10/LeetCode-解题报告/</id>
    <published>2016-09-10T15:20:55.000Z</published>
    <updated>2017-03-31T09:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<table>
<thead>
<tr>
<th>#</th>
<th>解题报告</th>
<th>分类</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>32</td>
<td><a href="http://stevechoris.github.io/2016/09/12/LeetCode-32-Longest-Valid-Parentheses/" target="_blank" rel="external">Longest Valid Parentheses</a></td>
<td><a href="http://stevechoris.github.io/tags/Dynamic-Programming/" target="_blank" rel="external">Dynamic Programming</a> <a href="http://stevechoris.github.io/all-tags/#Stack-list" target="_blank" rel="external">Stack</a> <a href="http://stevechoris.github.io/all-tags/#String-list" target="_blank" rel="external">String</a></td>
<td>Hard</td>
</tr>
<tr>
<td>174</td>
<td><a href="http://stevechoris.github.io/2016/09/11/LeetCode-174-Dungeon-Game/" target="_blank" rel="external">Dungeon Game</a></td>
<td><a href="http://stevechoris.github.io/tags/Dynamic-Programming/" target="_blank" rel="external">Dynamic Programming</a></td>
<td>Hard</td>
</tr>
<tr>
<td>312</td>
<td><a href="http://stevechoris.github.io/2016/09/11/LeetCode-312-Burst-Balloons/" target="_blank" rel="external">Burst Balloons</a></td>
<td><a href="http://stevechoris.github.io/tags/Dynamic-Programming/" target="_blank" rel="external">Dynamic Programming</a></td>
<td>Hard</td>
</tr>
<tr>
<td>354</td>
<td><a href="http://stevechoris.github.io/2016/09/11/LeetCode-354-Russian-Doll-Envelopes/" target="_blank" rel="external">Russian Doll Envelopes</a></td>
<td><a href="http://stevechoris.github.io/tags/Dynamic-Programming/" target="_blank" rel="external">Dynamic Programming</a></td>
<td>Hard</td>
</tr>
<tr>
<td>377</td>
<td><a href="http://stevechoris.github.io/2016/09/10/LeetCode-377-Combination-Sum/" target="_blank" rel="external">Combination Sum</a></td>
<td><a href="http://stevechoris.github.io/tags/Dynamic-Programming/" target="_blank" rel="external">Dynamic Programming</a></td>
<td>Medium</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>天使的模样</title>
    <link href="http://www.yingshu.ink/2016/09/10/Post-with-cover-image/"/>
    <id>http://www.yingshu.ink/2016/09/10/Post-with-cover-image/</id>
    <published>2016-09-10T13:29:21.000Z</published>
    <updated>2017-03-31T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>女孩的名叫海莉·福特，今年九岁，来自华盛顿州布雷默顿，与她小小的年龄不相称的是，她正举着钉枪，怀着大大的心意，在给流浪者建造庇护所。海莉说：“我觉得每个人都应该有一个住的地方，还有人无家可归，我得给他们建造房子。”目前，在妈妈和祖父的帮助下，海莉在社区里给无家可归的人们建造第一座木房子，希望能靠自己的努力来改变流浪汉们的生活。<br><img src="https://lh3.googleusercontent.com/Zp-gyIPPyW3_di9qyWkpmuzZLdo9_YUA_oh5aRVfbo4RCee-UbamG1Zul0P5b5cG5-XWFoIoK28jSTw5P0lMx2XPql28_nkAnY_Z900j9_tqdCwAMuJdebhxH0czigPyQtF5W2B3IjVHzkZfUak_QhyG0CV1NQseOIcx67l0LlSXM4NJDI91V2NwH3nx1qw9TmxavquFNVrHgHSZDu2-Q40-3HVBihqXB0BJ7ZVPnA88rqY9wlhy4AeySCXk9wOmEdSaah2DXcapBqM0QITdFt6EqqxATk_QFH7p0vW4oUYapnHCBtjKJTLJAfptKgeCMsa7-LRavFTfaCiBRHlesBznzic-_x7QP9f38h7TBGJtEYbJ68T019NEA59od-hVxBCpLKBthEWSjTDL9R-nwkFLCqgVPtomK1HzcP46h5jcSWjmd5-SEnCT0BtnPArmOrK38vSa3bkl_PTwII-KZcKkPXJgBJ76ppBraBrTJJbdVTpMqcIP_8Abdic5sowMz4DN2CuMoppxlTOc9Y2KSFdOX29bHaVPQQOnMdmm7XIexDno1Rwj6rcoVNxr2wk3aah5bjzRdervHQNK6QN4qMG5sMbLKhCZNDhFgfjsgbFxKMBR=w520-h356-no" alt="天使"></p>
<p>海莉为流浪汉们做公益已经有四年的时间了。那还是四年前，她她与妈妈米兰达逛完杂货铺出来，遇到了在当地丢失工作的流浪汉爱德华，他坐在路边，目光呆滞，已经很多天没吃饱饭了，饿得奄奄一息，五岁的海莉动了恻隐之心，跟妈妈商量着给爱德华买了个三明治。爱德华高兴得当场落泪，多年的流浪生涯让他看透了人情冷暖，世态的炎凉，而这个小女孩给了他温暖的一天。</p>
<p>在街上，海莉又遇到了另一个流浪汉比利·雷，一个退伍军人，在战争中失去了双腿，无家可归的他再次激起了海莉的爱心。帮完了一个又一个流浪汉后，母亲告诉她：“我们并不是多么富裕，没有能力帮助所有的人。”小女孩的眼角挂着泪水，倔强地看着母亲，她没有绝望，任性地说：“不！我要试试看！”买不起食物，她就自己去种。</p>
<p>就这样，这个善良的小女孩开始挖地，播种，除草，建栅栏，她要自己培育果蔬，为更多无家可归的人提供食物。没有种植经验，她就在晚上一个人抱着厚厚的书本学习，功夫不负有心人，她终于收获55磅的果蔬，悉数捐出，这可以满足流浪者一年的食量。如今，她的目标是收获250磅的食物，并通过自己动手，为流浪者建造庇护所，她拿起刀子，扛起电钻她要为流浪者建一个遮风避雨的小屋，带着口罩认真的粉刷墙壁。</p>
<p>为了资助海莉的项目，妈妈米兰达向一家非营利性组织申请了一笔补助，海莉收到了3000美元的赠款。当地的一家建材商店劳氏商店承诺，海莉来采购建屋的材料能最低打五折。</p>
<p>海莉的行动触动了一大批志愿者加入。一些爱心人士也纷纷伸出援助之手，给予海莉力所能及的帮助。一位女士，为那些女流浪者捐赠了女性用品，她将物品交给了海莉，并且告诉她“不够再来拿”。一家慈善机构知道海莉的故事后，给她捐了3000美元。她将这些钱用来购买一些生活用品，在一个圣诞节送给了流浪汉的孩子，“我看到了他们每个人都特别高兴，他们告诉我说我就是他们的圣诞老人。”</p>
<p>海莉的善举，成为了一股推动改善流浪汉生活的力量。在海莉的影响下，有人开始捐钱，有人开始捐种子，更多的人开始关注身边的流浪者，他们和这些无家可归的人聊天，尽可能的帮助他们。“不应该有人在街头流浪，流浪者们需要更多人的帮助！”海莉的故事正在改变世界流浪汉的现状。</p>
<p>尽自己最大的努力，怀揣一颗善良的心，去帮助那些需要帮助的人，这个世界就会因为你的小小善举而在慢慢发生改变。如果世界上真的有天使，那么天使应该就是这个女孩的模样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="模板" scheme="http://www.yingshu.ink/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>[LeetCode] 377. Combination Sum</title>
    <link href="http://www.yingshu.ink/2016/09/10/LeetCode-377-Combination-Sum/"/>
    <id>http://www.yingshu.ink/2016/09/10/LeetCode-377-Combination-Sum/</id>
    <published>2016-09-10T08:33:28.000Z</published>
    <updated>2017-03-31T09:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="external">377. Combination Sum IV</a><br>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<h2 id="example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><blockquote>
<p>nums = [1, 2, 3]<br>target = 4</p>
<p>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>Note that different sequences are counted as different combinations.</p>
<p>Therefore the output is 7.</p>
<h2 id="follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h2><p>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p>
</blockquote>
<h1 id="题目大意"><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给定一个无重复的正整数数组，计算得到一个目标正整数的所有可能组合方式的个数。</p>
<p>测试用例见题目描述。</p>
<p>注意不同的序列顺序应当视为不同的组合。</p>
<h2 id="进一步思考"><a href="#进一步思考：" class="headerlink" title="进一步思考："></a>进一步思考：</h2><p>给定一个无重复的正整数数组，计算得到一个目标正整数的所有可能组合方式的个数。</p>
<p>测试用例见题目描述。</p>
<p>注意不同的序列顺序应当视为不同的组合。</p>
<h1 id="解题思路"><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>动态规划（Dynamic Programming）</p>
<p>状态转移方程：dp[x + y] += dp[x]</p>
<p>其中dp[x]表示生成数字x的所有可能的组合方式的个数。</p>
<h1 id="python代码"><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):&#10;    def combinationSum4(self, nums, target):&#10;        &#34;&#34;&#34;&#10;        :type nums: List[int]&#10;        :type target: int&#10;        :rtype: int&#10;        &#34;&#34;&#34;&#10;        dp = [0] * (target + 1)&#10;        dp[0] = 1&#10;        for x in range(target + 1):&#10;            for y in nums:&#10;                if x + y &#60;= target:&#10;                    dp[x + y] += dp[x]&#10;        return dp[target]</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.yingshu.ink/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://www.yingshu.ink/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>图片博客模板</title>
    <link href="http://www.yingshu.ink/2016/06/09/%E5%9B%BE%E7%89%87%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/"/>
    <id>http://www.yingshu.ink/2016/06/09/图片博客模板/</id>
    <published>2016-06-09T05:33:36.000Z</published>
    <updated>2016-12-22T03:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/-Q-mL0R4-5xE/V9PJW_JCQYI/AAAAAAAAAL8/elGdM3Wd92I/I/12577849%25252C2560%25252C1600.jpg" alt="12577849,2560,1600"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-Q-mL0R4-5xE/V9PJW_JCQYI/AAAAAAAAAL8/elGdM3Wd92I/I/12577849%25252C2560%25252C1600.jpg&quot; alt=&quot;1
    
    </summary>
    
      <category term="模板" scheme="http://www.yingshu.ink/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="markdown" scheme="http://www.yingshu.ink/tags/markdown/"/>
    
      <category term="中文" scheme="http://www.yingshu.ink/tags/%E4%B8%AD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 安装扩展插件</title>
    <link href="http://www.yingshu.ink/2016/05/29/Jupyter-Notebook-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.yingshu.ink/2016/05/29/Jupyter-Notebook-安装扩展插件/</id>
    <published>2016-05-29T07:54:37.000Z</published>
    <updated>2017-03-31T09:06:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="更新pip"><a href="#更新pip" class="headerlink" title="更新pip"></a>更新pip</h2><blockquote>
<p>最简单的安装方法是使用pip，首先将pip更新到最新版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="安装jupyter-notebook-扩展"><a href="#安装Jupyter-Notebook-扩展" class="headerlink" title="安装Jupyter Notebook 扩展"></a>安装Jupyter Notebook 扩展</h2><blockquote>
<p>安装方法可以参考GitHub Jupyter Notebook主页上的<a href="https://github.com/ipython-contrib/IPython-notebook-extensions" target="_blank" rel="external">README.md</a>文档，最简单的方法是pip install</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install https://github.com/ipython-contrib/IPython-notebook-extensions/archive/master.zip --user</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>网络不好的时候可以选择离线安装</li>
<li>需要将anaconda目录添加读写权限</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;
    
    </summary>
    
      <category term="开发环境配置" scheme="http://www.yingshu.ink/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Python" scheme="http://www.yingshu.ink/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>文字博客模板</title>
    <link href="http://www.yingshu.ink/2016/05/25/%E6%96%87%E5%AD%97%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/"/>
    <id>http://www.yingshu.ink/2016/05/25/文字博客模板/</id>
    <published>2016-05-25T15:26:46.000Z</published>
    <updated>2017-03-31T08:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is a test template</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a test template&lt;/p&gt;

    
    </summary>
    
      <category term="模板" scheme="http://www.yingshu.ink/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="markdown" scheme="http://www.yingshu.ink/tags/markdown/"/>
    
      <category term="中文" scheme="http://www.yingshu.ink/tags/%E4%B8%AD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.yingshu.ink/2016/05/25/hello-world/"/>
    <id>http://www.yingshu.ink/2016/05/25/hello-world/</id>
    <published>2016-05-25T13:49:35.000Z</published>
    <updated>2016-05-25T13:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="quick-start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
    
    </summary>
    
    
  </entry>
  
</feed>
